(ns app.core
  (:require [reagent.core :as r]
            [reagent.dom :as dom]
            [stylo.core :refer [c c?]]
            [reitit.frontend :as rf]
            [reitit.frontend.easy :as rfe]
            [reitit.coercion.spec :as rss]
            [clojure.string :as str]))

(def compiler
  (r/create-compiler {:function-components true}))

(defn p
  ([content]
   [:p {:class (c [:mt 1] :text-base :text-gray-500)}
    content])
  ([content & other-content]
   [:p {:class (c [:mt 1] :text-base :text-gray-500)}
    content other-content]))

(defn pre-bash [content] 
   [:div {:style {:background-color :black :width :min-content :border-radius "6px"}
              :class (c [:m 1])}
        [:pre {:class (c [:text :white])}
         content]])

(defn heading [& content]
  [:div {:class (c :box-border [:pb 10] [:mb 10]  [:border-b :gray-200])}
   [:h1 {:class (c [:m 1] :text-3xl :inline-block :extrabold [:text :gray-900] :tracking-tight)}
    content]])

(defn a 
  ([link] 
   (a link link))
  ([link description]
    [:a {:href link
         :class (c [:text :blue-300] :underline)} description]))

(defn about []
  [:div {:class (c :content-center [:mt 8])}
   (heading "Philosophy."
            (p "StyloCSS develops an idea of storing all css in one place without actually touching any .css file.")
            (p "It was inspired by Tailwind CSS. But we want to go far beyond.")
            (p "Library develops an idea of storing all css in one place without actually touching any .css file.")
            (p " Isntall the Stylo library and keep your focus on styling, not typing. Let the macro do the rest of routine. ")
            (p " P.S. library is based on macro, so we need some alchemy to make it work in ClojureScript environment, ")
            (p " but we prepared " (a (rfe/href ::installation) "installation guide")))
   (heading "Version and compatibility. " 
            (p "Latest version is 0.1.0")
            (p "Tested with: " [:ul 
                                [:li "ClojureScript 10.10.866"]
                                [:li "Clojure 1.10.0"]])
            (p "Status: usable alpha."))
   (heading "Distribution and license: "
            (p "Copyright Â© belongs to HealthSamurai and contributors.")
            (p "Distributed under the Eclipse Public License 2.0")
            (p "Logo is a property of HealthSamurai, but you can make a T-shirt with it free of charge."))])

(defn installation []
  [:div
   [:div {:class (c :content-center [:mt 8])}
    (heading "Installation"
             (p  "Learn to set up shadow-cljs from the scratch in your project. "))]
   [:div {:class (c :content-center [:mt 8])}
    (heading "shadow-cljs"
             (p "1. We create a shadowcljs template:"
                (pre-bash "lein new shadow-cljs shadow-example +reagent"))

             (p "Don't forget to install all necessary js packages: "
                (pre-bash "npm install"))
             (p "Other available options of shadow-cljs are given here: "
                (a "https://github.com/shadow-cljs/lein-template"))
             (p "2. Add  into dependencies: ")
             (p " " [:pre "[stylo-css \"0.1.0 \"]"])
             (p " 3. Open up your shadow-cljs.edn configuration file and add"
                (pre-bash ":build-hooks [(stylo.shadow/reload {PATH-TO-CSS})]"))
             (p "  into the :app configuration. {PATH-TO-CSS} - is a path where the css file will be generated.")
             (p "  Our configuration should look like this: "
                (pre-bash "{... \n :builds \n {:app \n \n {... \n \n :build-hooks [(stylo.shadow/reload \"public/out/stylo/css/stylo.css\")]}}}"))
             (p  "4. Open public/index.html file, it is generated by shadow-cljs by default. We should add the new source of css into it. ")
             (p "Add the following into the <head> </head> section: "
                (pre-bash " <link href= {PATH-TO-CSS} rel= \"stylesheet\">"))
             (p "5. So, you it is time to use the library. 
           Comprehensive documetation may be read by the link:  "
                (a "github.com/stylo-css/docs"))
             (p "  The basic syntax is the following: "
                (pre-bash "[:div {:class (c [:pt 8] :h-screen)}] "))
             (p "c - is our macro, it waits for classes alias as arguments ")
             (p ":h-screen [:pt 8] - class alias ")
             (p "when class needs some configuration - it is passed as a vector [:pt 8] - where :pt is class alias and 6 - it's value "))]
   [:div {:class (c :content-center [:mt 8])}
    (heading "figwheel"
             (p "Documentation for figwheel is in progress."))]])

(defonce match (r/atom nil))

(def menu-clicked-state (r/atom {::about false 
                                 ::installation false 
                                 ::documentation false}))

(defn set-all-to-false-except-key [m k]
  (merge (assoc m k true)
         (->> m
              keys
              (remove #{k})
              (reduce (fn [acc v] (assoc acc v false)) {}))))

(defn light-clicked [k]
 (swap! menu-clicked-state set-all-to-false-except-key k))

(defn clicked? [k] 
  (if (k @menu-clicked-state)
    (c [:text :blue-600] [:pseudo :hover [:text :blue-300]])
    (c [:pseudo :hover [:text :blue-300]])))

(defn menu-item 
  ([k] (menu-item k (-> k
                        name
                        str 
                        str/capitalize)))
  ([k description]
  
  [:a {:href (rfe/href k)
       :class (clicked? k)
       :on-click #(light-clicked k)} description]))

(defn current-page []
  [:div {:class (c :flex :flex-row)}
   [:nav {:class (c :flex :flex-column [:mx 5] [:mt 8])}
    [:ul
     [:li (menu-item ::about)]
     [:li (menu-item ::installation)]
     [:li (menu-item ::documentation)]]]
   (when @match
     (let [_ (println @match)
           view (:view (:data @match))]
       [view @match]))])

(def routes
  [["/"
    {:name ::about
     :view about}]

   ["/installation"
    {:name ::installation
     :view installation}]
   
   ["/documentation"
    {:name ::documentation
     :view installation}]])

(defn init! []
  (rfe/start!
   (rf/router routes {:data {:coercion rss/coercion}})
   (fn [m] (reset! match m))
    ;; set to false to enable HistoryAPI
   {:use-fragment true})
  (dom/render
   [current-page]
   (js/document.getElementById "app")
   compiler))

(init!)

