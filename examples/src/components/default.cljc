(ns components.default
  (:require [components.hiccup :as h]
            [stylo.core :refer [c]]))

(defn about
  []

  (h/block

   (h/block
   (h/h1
    "Philosophy of library.")
    (h/p1
     "StyloCSS develops an idea of storing all css in one place without actually touching any .css file.")
    (h/p1 "It was inspired by Tailwind CSS. But we want to go far beyond.")
    (h/p1
     "Library develops an idea of storing all css in one place without actually touching any .css file.")
    (h/p1 "Install the Stylo library and keep your focus on styling, not typing. Let the macro do the rest of routine. ")
    (h/p1
     " P.S. library is based on macro, so we need some alchemy to make it work in ClojureScript environment, ")
    (h/p1 " but we prepared " (h/a "#installation" "installation") " guide"))

  (h/block
   (h/h1 "Version and compatibility. ")
      (h/p1 "Latest version is 0.1.0")
      (h/p1 "Tested with: ")
      (h/p1 "Clojure 1.10.0")
      (h/p1 "ClojureScript 10.10.866")
      (h/p1 "Status: usable alpha."))

  (h/block
    (h/h1 "Distribution and license: ")
    (h/p1 "Copyright Â© belongs to HealthSamurai and contributors.")
    (h/p1 "Distributed under the Eclipse Public License 2.0")
    (h/p1 "Logo is a property of HealthSamurai, but you can make a T-shirt with it free of charge."))))

(defn installation
  []
  (h/block
   (h/block
    (h/h1 "Installation")
    (h/p1 "Learn to set up shadow-cljs from the scratch in your project. "))
   (h/block
    (h/h3 "Installing using shadow-cljs and Leiningen")
    (h/p3 "At first we need to create a new shadow-cljs template.")
    (h/code :bash "lein new shadow-cljs shadow-example +reagent")
    (h/p3 "Don't forget to install all necessary js packages: ")
    (h/code :bash "npm install")
    (h/p3 "Other available options of shadow-cljs are given here: "
       (h/a "https://github.com/shadow-cljs/lein-template"))
    (h/p3 "Add  into " [:span {:class (c :font-bold)
                             :key (h/gen-key)} " project.clj "] " dependencies: ")
    (h/code :clojure
            (h/lint "[stylo-css \"0.1.0 \"]"))
    (h/p3 "Open up your" [:span {:class (c :font-bold)
                               :key (h/gen-key)} " shadow-cljs.edn "] "configuration file and add")
    (h/code :clojure
            (h/lint "{ :build-hooks [(stylo.shadow/reload \"public/out/stylo/css/stylo.css\")]}"))
    (h/p3 "  into the :app configuration."
        [:span {:class (c :font-bold)
                :key (h/gen-key)} " NB! "]
        "Path written below is the path where the css file will be generated. Do not just copy and paste, find your own location.")
    (h/p3 " Our configuration should look like this: ")
    (h/code :clojure (h/lint "{... \n :builds \n {:app \n \n {... \n \n :build-hooks [(stylo.shadow/reload \"public/out/stylo/css/stylo.css\")]}}}"))
    (h/p3
     "Open public/index.html file, it is generated by shadow-cljs by default. We should add the new source of css into it. ")
    (h/p3 "Add the following into the <head> </head> section: ")
    (h/code :clojure (h/lint " <link href= \"out/stylo/css/stylo.css\" rel= \"stylesheet\">"))
    (h/block
     (h/h3 "Lets go!")
     (h/p3
     "So, it is time to use the library!
        Comprehensive documetation may be read "  (h/a "/documentation" "here") ".")
     (h/p3 "This landing is done using macroCSS library, so it may explain some conceptions via code: "
         (h/a "https://github.com/HealthSamurai/macrocss/tree/master/examples" "github/examples."))))
  (h/block
    (h/h3 "figwheel")
    (h/p3 "Documentation for figwheel is in progress."))))

(defn basic-syntax
  []
  (h/block
   (h/block
    (h/h1 "Basic Syntax.")
    (h/p1 " Essential library usage scenarios."))
  (h/block
   (h/h3 "Actually, it is not a rocket science.")
   (h/p3 "You just require library and do some little magic to make macros work in ClojureScript: ")
   (h/code :clojure (h/lint "(ns wonderful-ns.core \n  (:require-macros \n  [stylo.core :refer [c]])) \n\n")
                     (h/comment-code ";; c - hey, it's out macro, it waits for class alias as arguments \n\n")
                     (h/lint "[:div {:class (c [:pt 8] :h-screen)}] \n \n")
                     (h/comment-code ";; :h-screen and [:pt 8] - those keywords are just our version \n;; of Tailwind classnames"))

    (h/p3 "Maybe you have already started to suspect, but when class needs some extra input (e.g. size, color, weight etc.) \n - it is passed as a vector.
    Let us try to explain what happens here: ")
    (h/code :clojure (h/lint "(c [:pt 8])  \n\n")
                     (h/comment-code ";; once used inside a component \n")
                     (h/comment-code ";; it generates css with unique classname \n")
                     (h/comment-code ";; (c [:pt 8]) will always return class :c-1581282564 \n")
                     (h/comment-code ";; and properties {'padding-top:' 8rem}  \n")
                     (h/comment-code ";; classname is not random, it's a hash (sic!) \n")
                     (h/comment-code ";; every component with same set of properties \n")
                     (h/comment-code ";; will have the same class name \n")
                     (h/comment-code ";; isn't it more convenient than 'pt-8' in Tailwind? \n")
                     (h/comment-code ";; when you do not use class inside a component \n")
                     (h/comment-code ";; it is swiped out from css file - no useless or dead CSS.")))
  (h/block
   (h/h3 "Use it as constructor!")
   (h/p3 "Whether you face situations when you have not found needed css rules \n
        or you have found some inconvenience using pre-defined css - \n
        adding your own is not a big deal.")
   (h/p3 "Adding a single style may be done by registering new method, we call it " (h/code-span "rule") ".")
   (h/p3 "For example - you want to make special style for Apple Iphone XR (c) users: ")
   (h/code :clojure (h/lint "(ns your-wonderful-code.core \n  (:require [stylo.rule :refer [rule]])) \n\n")
                    (h/comment-code ";; Add your custom rule (if styles do not appear after hot-reload \n")
                    (h/comment-code ";; - we recommend to recompile project) \n")
                    (h/comment-code ";; If styles are not added even after - clean \n")
                    (h/comment-code ";; .cpcache .shadow-cljs and public/out folders \n\n")
                    (h/lint "(defmethod rule :w-max-iphone-xr [_] \n")
                    (h/lint "  [[:& {:max-width \"414px\"}]]) \n \n")
                    (h/lint "(defn apple-geek-div [] [:div {:class (c :w-max-iphone-xr)}])\n\n")
                    (h/comment-code ";; And it just works. Seemlessly."))
   (h/p3 "But what if we want to add rules for a bunch of different phones. Not just a single model?")
   (h/p3 "We have a solution for this case. Luke, use "  (h/code-span "defrules") "!")
   (h/code :clojure (h/lint "(ns your-wonderful-code.core \n")
                    (h/lint "  (:require [stylo.rule :refer [defrules]])) \n\n")
                    (h/comment-code ";; Defrules receives [k v] structure as an argument. \n")
                    (h/comment-code ";; Hash-map is a perfect solution for it, isn't it? \n\n")
                    (h/lint "(def iphones-wmax {:w-max-iphone-12 {:max-width \"390px\"} \n")
                    (h/lint "                   :w-max-iphone-11 {:max-width \"414px\"} \n")
                    (h/lint "                   :w-max-iphone-x {:max-wdith \"375px\"}}) \n\n")
                    (h/comment-code ";; So let's use defrules \n\n")
                    (h/lint "(defrules iphone-wmax) \n\n")
                    (h/lint "(defn one-more-apple-geek-div [] \n")
                    (h/lint "  [:div {:class (c :w-max-iphone-12)}])\n\n")
                    (h/comment-code ";; And yes. It just works. Seemlessly. \n\n")))))
